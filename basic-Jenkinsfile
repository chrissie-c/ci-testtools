void setBuildStatus(String message, String state) {
  step([
      $class: "GitHubCommitStatusSetter",
      reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/kronosnet/knet-ci-test.git"],
      contextSource: [$class: "ManuallyEnteredCommitContextSource", context: "ci/jenkins/build-status"],
      errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult", message: message, state: state]] ]
  ]);
}

boolean getAuthCheck()
{
    branchEvent = currentBuild.getBuildCauses('jenkins.branch.BranchEventCause');
    cause = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause');

    echo "getAuthCheck. branchEvent = ${branchEvent}"
    echo "getAuthCheck. cause = ${cause}"
    echo "getAuthCheck. CHANGE_AUTHOR = ${env.CHANGE_AUTHOR}"


    if (branchEvent.size().equals(0)) {
	// Triggered internally
	return true;
    }
    // Caused by a github(etc) PR. Check users
    if ((env.CHANGE_AUTHOR == 'chrissie-c') ||
	(env.CHANGE_AUTHOR == 'fabbione')) {
	return true;
    }

    // Unknown user - get approval to run this
    echo "Approval needed from Jenkins administrator"
    result = input(message: "Is this safe to run?", ok: "OK",
		   submitterParameter: 'submitter')
    println(result);

    /// mostly generated by ChatGPT
    def pullRequestId = env.CHANGE_ID.split('/').last()
    def gitHubPRUrl = "https://api.github.com/repos/${env.CHANGE_OWNER}/${env.CHANGE_REPO}/issues/${pullRequestId}/comments"
    def commentId = ''
    def message = "Can one of the admins verify this patch please?"
    
    // Post the question as a comment on the pull request
    def response = sh(script: "curl -s -X POST -H 'Authorization: token ${env.GITHUB_TOKEN}' -d '{\"body\":\"${message}\"}' ${gitHubPRUrl}", returnStdout: true)
    commentId = sh(script: "echo '${response}' | jq '.id'", returnStdout: true).trim()
    
    // Wait for an answer in the pull request comments
    def foundAnswer = false
    def numRetries = 0
    while (!foundAnswer && numRetries < 10) {
        // Wait for 30 seconds before checking for new comments
        sleep 30
        
        // Retrieve the pull request comments and search for an answer
        def commentsUrl = "https://api.github.com/repos/${env.CHANGE_OWNER}/${env.CHANGE_REPO}/issues/${pullRequestId}/comments"
        def comments = sh(script: "curl -s -H 'Authorization: token ${env.GITHUB_TOKEN}' ${commentsUrl}", returnStdout: true)
        def commentList = new groovy.json.JsonSlurper().parseText(comments)
        commentList.each { comment ->
            if (comment.in_reply_to_id == commentId) {
                echo "Answer: ${comment.body}"
                foundAnswer = true
            }
	    echo "MESSAGE from ${comment.user.login}: ${comment.body}"
	    /// CC: Check who answered the question!
	    if (((comment.user.login == "chrissie-c") ||
		 (comment.user.login == "fabbione")) &&
		(comment.body.contains("OK"))) {
		return true;
	    }
	}
	numRetries++
    }
    
    if (!foundAnswer) {
        echo "No answer received within 50 seconds"
	return false;
    }
    return false;
}

def authcheck = getAuthCheck()

pipeline {
    parameters {
        string(name: 'NODES', defaultValue: 'fedora37', description: 'Set of nodes(labels) to run on')
    }
    agent {
	label params.NODES
    }

    stages {
	stage('Not allowed') {
	    when {
		expression { authcheck != true }
	    }
	    // Not really a failure, but I'm testing
	    stages {
		stage('notify') {
		    steps {
			sh "env"
			sh "echo authcheck: ${authcheck}"
			setBuildStatus("Build not run", "FAILURE");
		    }
		}
	    }
	}
	stage('Build and test') {
	    when {
		expression { authcheck == true }
	    }
	    stages {
                stage('Prep') {
                    steps {
			sh "env"
			sh "echo authcheck: ${authcheck}"
                        sh 'sh autogen.sh'
                        sh 'PKG_CONFIG_PATH=/srv/knet/origin/main/lib/pkgconfig/ ./configure'
                    }
                }
                stage('Build') {
                    steps {
			sh 'make all'
                    }
                }
                stage('Test') {
                    steps {
			sh 'make check'
                    }
                }
                stage('Dist Check') {
                    steps {
			sh 'make distcheck DISTCHECK_CONFIGURE_FLAGS="PKG_CONFIG_PATH=/srv/knet/origin/main/lib/pkgconfig/"'
                    }
                }
            }
	}
    }
}
