void setBuildStatus(String message, String state) {
  step([
      $class: "GitHubCommitStatusSetter",
      reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/kronosnet/knet-ci-test.git"],
      contextSource: [$class: "ManuallyEnteredCommitContextSource", context: "ci/jenkins/build-status"],
      errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult", message: message, state: state]] ]
  ]);
}

boolean getAuthCheck()
{
    branchEvent = currentBuild.getBuildCauses('jenkins.branch.BranchEventCause');
    cause = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause');

    echo "getAuthCheck. branchEvent = ${branchEvent}"
    echo "getAuthCheck. cause = ${cause}"
    echo "getAuthCheck. CHANGE_AUTHOR = ${env.CHANGE_AUTHOR}"

    if (branchEvent.size().equals(0)) {
	// Triggered internally
	return true;
    }
    // Caused by a github(etc) PR. Check users
    if ((env.CHANGE_AUTHOR == 'chrissie-c') ||
	(env.CHANGE_AUTHOR == 'fabbione')) {
	return true;
    }

    // Unknown user - get approval to run this

    // Put a message in github that links to this job run
    clusterLibSendReply("github", "Can one of the admins check and authorise this run please: ${env.BUILD_URL}input");

    // Ask for approval
    echo "Approval needed from Jenkins administrator"
    result = input(message: "<a href=\"${env.CHANGE_URL}/files\">please verify this is safe to run</a>", ok: "OK",
		   submitterParameter: 'submitter')
    println(result);

    // If we get this far then it's been approved. Abort is the other option!
    return true;
}

def authcheck = false;

pipeline {
    parameters {
	// Not used, but left here for info.
        string(name: 'TIMEOUT', defaultValue: '60', description: 'Job timeout (in minutes)')
    }
    agent none

    options {
	timeout(time: 60, unit: 'MINUTES')
//	timeout(time: params.TIMEOUT.toInteger(), unit: 'MINUTES')
	timestamps()
    }

    stages {
	stage('Check user') {
	    steps {
		node('nobuild') {
		    script {
			authcheck = getAuthCheck()
		    }
		}
	    }
	}
	stage('Not allowed') {
	    when {
		expression { authcheck != true }
	    }
	    // Not really a failure, but I'm testing
	    stages {
		stage('notify') {
		    steps {
			sh "env|sort"
			sh "echo authcheck: ${authcheck}"
			setBuildStatus("Build not run", "FAILURE");
		    }
		}
	    }
	}
	stage('Build and test') {
	    when {
		expression { authcheck == true }
	    }
	    matrix {
		agent {
		    label "${PLATFORM}"
		}
		axes {
		    axis {
			name 'PLATFORM'
			values 'T-fedora37-x86-64', 'T-debian-testing-x86-64', 'T-freebsd-13-x86-64', 'T-rhel7-x86-64'
		    }
		    axis {
			name 'FUNCTION'
			values 'voting', 'coverity', 'non-voting'
		    }
		}
		excludes {
		    exclude {
			axis {
			    name 'PLATFORM'
			    values 'T-debian-testing-x86-64', 'T-freebsd-13-x86-64', 'T-rhel7-x86-64'
			}
			axis {
			    name 'FUNCTION'
			    values 'non-voting'
			}
		    }
		    exclude {
			axis {
			    name 'PLATFORM'
			    values 'T-fedora37-x86-64', 'T-debian-testing-x86-64', 'T-freebsd-13-x86-64'
			}
			axis {
			    name 'FUNCTION'
			    values 'coverity'
			}
		    }
		    exclude {
			axis {
			    name 'PLATFORM'
			    values 'T-fedora37-x86-64', 'T-freebsd-13-x86-64'
			}
			axis {
			    name 'FUNCTION'
			    values 'voting'
			}
		    }
		}
		stages {
                    stage('Prep') {
			steps {
			    sh "env|sort"
			    sh "echo authcheck: ${authcheck}"
                            sh 'sh autogen.sh'
                            sh 'PKG_CONFIG_PATH=/srv/knet/origin/main/lib/pkgconfig/ ./configure'
			}
                    }
                    stage('Build') {
			steps {
			    script {
				try {
				    sh 'make grot'
				} catch (err) {
				    if (FUNCTION == "voting" ) {
					throw err
				    }
				    echo "Error in non-voting job: $err"
				}
			    }
			}
                    }
                    stage('Test') {
			steps {
			    sh 'make check'
			}
                    }
                    stage('Dist Check') {
			steps {
			    sh 'make distcheck DISTCHECK_CONFIGURE_FLAGS="PKG_CONFIG_PATH=/srv/knet/origin/main/lib/pkgconfig/"'
			}
                    }
		    // TODO: not sure how to make a failing non-voting jobs not faile the whole pipeline yet
		    stage('Coverity') {
			when {
			    beforeAgent true
			    expression { FUNCTION = "coverity" }
			}
			steps {
			    sh "echo This is where COVSCAN happens"
			}
		    }
		}
	    }
	}
    }
}
